import logging
import os
import json
import time

from .message import Message
from oauthlib.oauth2 import TokenExpiredError
from requests_oauthlib import OAuth2Session

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
log = logging.getLogger(__name__)


class MicroDict(dict):
	def __getitem__(self, key):
		result = super(MicroDict, self).get(key[:1].lower() + key[1:], None)
		if result is None:
			result = super(MicroDict, self).get(key[:1].upper() + key[1:])
		return result


class Inbox:
	_oauth2_authorize_url = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize'
	_oauth2_token_url = 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
	redirect_uri = 'https://outlook.office365.com/owa/'

	_home_path = os.path.expanduser("~")
	default_token_path = os.path.join(_home_path, '.o365_token')

	def __init__(self, client_id, client_secret):
		""" Connect to office 365 using specified Open Authentication protocol

        :param client_id: application_id generated by https://apps.dev.microsoft.com when you register your app
        :param client_secret: secret password tranp_key generated for your application
        """
		self.inbox_url = 'https://graph.microsoft.com/v1.0/me/messages'
		self.folders_url = 'https://graph.microsoft.com/v1.0/me/MailFolders'
		self.folder_url = 'https://graph.microsoft.com/v1.0/me/MailFolders/{folder_id}/messages'

		self.oauth = None
		self.token = None
		self.client_id = client_id
		self.client_secret = client_secret

		self.verify = True
		self.filter = ""
		self.messages = []
		self.url = ""

		self.load_token()

	def load_token(self):
		"""
		:return: token from the file
		"""
		if os.path.exists(Inbox.default_token_path):
			with open(Inbox.default_token_path, 'r') as token_file:
				token = json.load(token_file)

			if token["expires_at"] >= time.time():
				self.token = token
				log.info("Loading token...Token is good, getting oauth object")
				self.oauth = OAuth2Session(client_id=self.client_id, token=token)

			else:
				log.info("Token from token file doesn't found or expired, fetching new token")
				os.unlink(Inbox.default_token_path)
				self.get_oauth2_token()
		else:
			self.get_oauth2_token()

	def save_token(self, token):
		with open(Inbox.default_token_path, 'w') as token_file:
			json.dump(token, token_file, indent=True)

	def get_oauth2_token(self):
		try:
			self.oauth = OAuth2Session(client_id=self.client_id, redirect_uri=Inbox.redirect_uri,
									   scope=['https://graph.microsoft.com/Mail.ReadWrite',
											  'https://graph.microsoft.com/Mail.Send', 'offline_access'])
			oauth = self.oauth
			auth_url, state = oauth.authorization_url(url=Inbox._oauth2_authorize_url, access_type='offline')
			print('Please open {} and authorize the application'.format(auth_url))
			auth_resp = input('Enter the full result url: ')
			os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = '1'
			os.environ['OAUTHLIB_IGNORE_SCOPE_CHANGE'] = '1'
			token = oauth.fetch_token(token_url=Inbox._oauth2_token_url, authorization_response=auth_resp,
									  client_secret=self.client_secret)
			self.token = token
			self.save_token(token)
		except Exception as e:
			log.error("Exception caught in get_oauth2_token(): %s", e)

	def refresh_token(self):
		token = self.oauth.refresh_token(Inbox._oauth2_token_url, client_id=self.client_id,
										 client_secret=self.client_secret)
		self.save_token(token)
		self.token = token
		log.info('Token refreshed')

	def get_response_GET(self, request_url, **kwargs):
		con_params = {}
		con_params.update(kwargs)

		try:
			response = self.oauth.get(request_url, **con_params)

		except TokenExpiredError:
			log.info('Token is expired, fetching a new token')
			self.refresh_token()
			response = self.oauth.get(request_url, **con_params)

		try:
			response_json = response.json()
			response_values = [MicroDict(x) for x in response_json['value']]
			return response_values

		except Exception as e:
			log.error("Something went wrong in get_responce_GET(), %s", e)

	def get_response_POST(self, request_url):
		try:
			response = self.oauth.post(request_url)
		except TokenExpiredError:
			log.info('Token is expired, fetching a new token')
			self.refresh_token()
			response = self.oauth.post(request_url)

		response_json = response.json()
		response_values = MicroDict(response_json)
		return response_values

	def get_response_PATCH(self, id, update_json):
		update_draft_url = self.url + "/" + id + "?$select=uniqueBody"
		headers = {'Content-type': 'application/json', 'Accept': 'application/json'}

		try:
			response = self.oauth.patch(update_draft_url, update_json, headers=headers, verify=True)
		except TokenExpiredError:
			log.info('Token is expired, fetching a new token')
			self.refresh_token()
			response = self.oauth.patch(update_draft_url, update_json, headers=headers, verify=True)

		response_json = response.json()
		response_values = MicroDict(response_json)
		return response_values

	def from_folder(self, folder_name):
		""" Configure to use this folder for fetching  emails
        :param folder_name: name of the outlook folder
        """

		response = self.get_response_GET(self.folders_url, verify=self.verify, params={'$top': 21})

		folder_id = None
		all_folders = []

		for folder in response:
			if folder['displayName'] == folder_name:
				folder_id = folder['id']
				break
			all_folders.append(folder['displayName'])

		if not folder_id:
			raise RuntimeError(f'Folder "{folder_name}" is not found, available folders are {all_folders}')

		self.url = self.folder_url.format(folder_id=folder_id)

		return self

	def set_filter(self, filter_string):
		""" Set the value of a filter. More information on what filters are available can be found here:
        https://msdn.microsoft.com/office/office365/APi/complex-types-for-mail-contacts-calendar#RESTAPIResourcesMessage
        More improvements coming soon
        :param filter_string: The string that represents the filters you want to enact.
                should be something like: (HasAttachments eq true) and (IsRead eq false) or just: IsRead eq false
                test your filter string here: https://outlook.office365.com/api/v1.0/me/messages?$filter=
                if that accepts it then you know it works.
        """
		self.filter = filter_string
		return self

	def fetch(self, count=1, search_string=None):
		""" Fetch messages and return in reverse order, so we maintain proper email history
        :param search_string:
        :param count: number of messages to fetch
        """

		if search_string is not None:
			params = {'$top': count, '$search': '"{}"'.format(search_string)}  # , "$select":"uniqueBody"}
		else:
			params = {'$filter': self.filter, '$top': count,
					  '$orderby': "receivedDateTime asc"}  # , "$select":"uniqueBody"}

		messages = []
		response = self.get_response_GET(self.url, verify=self.verify, params=params)
		for message in response:
			messages.append(Message(message, self))

		return messages
